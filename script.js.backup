// Main script to build and interact with family tree

// Render the family tree
function renderFamilyTree() {
    const container = document.getElementById('family-tree');
    container.innerHTML = '';
    
    // Create grandparents section (top)
    const grandparentSection = document.createElement('div');
    grandparentSection.className = 'generation';
    grandparentSection.id = 'generation-grandparents';
    
    const grandfather = familyData.grandfather;
    const grandmother = familyData.grandmother;
    
    // Create person card for grandfather and grandmother
    const grandfatherCard = createPersonCard(grandfather);
    const grandmotherCard = createPersonCard(grandmother);
    
    grandparentSection.appendChild(grandfatherCard);
    grandparentSection.appendChild(grandmotherCard);
    
    container.appendChild(grandparentSection);
    
    // Get all children IDs from both grandparents
    const allChildren = new Set([
        ...(grandfather.children || []),
        ...(grandmother.children || [])
    ]);
    
    // Create children sections grouped by generation
    renderGenerations(Array.from(allChildren), container, 1);
}

// Get family member by ID
function getFamilyMember(id) {
    return familyData[id];
}

// Render multiple generations
function renderGenerations(childrenIds, container, generationLevel) {
    if (childrenIds.length === 0) return;
    
    // Only show first 3 generations (grandparents, aunts/uncles, grandchildren)
    if (generationLevel > 2) return;
    
    // Add generation label
    const generationContainer = document.createElement('div');
    const label = document.createElement('div');
    label.className = 'generation-label';
    const labels = ['', 'Children', 'Grandchildren'];
    label.textContent = labels[generationLevel] || '';
    if (generationLevel > 0) {
        generationContainer.appendChild(label);
    }
    
    const generation = document.createElement('div');
    generation.className = 'generation';
    generation.id = `generation-${generationLevel}`;
    
    childrenIds.forEach(childId => {
        const child = getFamilyMember(childId);
        if (child) {
            const card = createPersonCard(child);
            generation.appendChild(card);
        }
    });
    
    generationContainer.appendChild(generation);
    container.appendChild(generationContainer);
    
    // Recursively render next generation
    const nextGenChildren = [];
    childrenIds.forEach(childId => {
        const child = getFamilyMember(childId);
        if (child && child.children && child.children.length > 0) {
            nextGenChildren.push(...child.children);
        }
    });
    
    if (nextGenChildren.length > 0) {
        renderGenerations(nextGenChildren, container, generationLevel + 1);
    }
}

// Create a person card element
function createPersonCard(person) {
    const card = document.createElement('div');
    card.className = 'person-card';
    card.setAttribute('data-person-id', person.id);
    
    const img = document.createElement('img');
    img.src = person.image;
    img.alt = person.name;
    img.className = 'person-photo';
    img.onerror = function() {
        this.src = 'images/profile_image.png';
    };
    
    const name = document.createElement('div');
    name.className = 'person-name';
    name.textContent = person.name;
    
    card.appendChild(img);
    card.appendChild(name);
    
    // Add click event to show extended family
    card.addEventListener('click', () => {
        showPersonDetails(person);
    });
    
    return card;
}

// Show person details in modal
function showPersonDetails(person) {
    const modal = document.getElementById('person-modal');
    const modalBody = document.getElementById('modal-body');
    
    modalBody.innerHTML = `
        <div class="modal-header">
            <img src="${person.image}" alt="${person.name}" class="modal-photo" 
                 onerror="this.src='images/profile_image.png'">
            <div class="modal-info">
                <h2>${person.name}</h2>
                <p><strong>Born:</strong> ${person.yearBorn}</p>
                ${person.yearPassed ? `<p><strong>Passed:</strong> ${person.yearPassed}</p>` : ''}
                ${person.location ? `<p><strong>Location:</strong> ${person.location}</p>` : ''}
            </div>
        </div>
        
        ${person.children && person.children.length > 0 ? `
            <div class="modal-children">
                <h3>Children</h3>
                <div class="children-grid">
                    ${person.children.map(childId => {
                        const child = getFamilyMember(childId);
                        if (!child) return '';
                        return `
                            <div class="person-card modal-child-card" style="margin-bottom: 20px; cursor: pointer;" data-child-id="${childId}">
                                <img src="${child.image}" alt="${child.name}" class="person-photo" 
                                     style="width: 80px; height: 80px;"
                                     onerror="this.src='images/profile_image.png'">
                                <div class="person-name" style="font-size: 0.9rem;">${child.name}</div>
                            </div>
                        `;
                    }).join('')}
                </div>
            </div>
        ` : '<div class="no-children">No children listed</div>'}
    `;
    
    modal.style.display = 'block';
    
    // Add click handlers to modal children
    document.querySelectorAll('.modal-child-card').forEach(card => {
        card.addEventListener('click', (e) => {
            e.stopPropagation();
            const childId = e.currentTarget.getAttribute('data-child-id');
            const child = getFamilyMember(childId);
            if (child) {
                showPersonDetails(child);
            }
        });
    });
}

// Close modal when clicking X
document.querySelector('.close').addEventListener('click', () => {
    document.getElementById('person-modal').style.display = 'none';
});

// Close modal when clicking outside
window.addEventListener('click', (event) => {
    const modal = document.getElementById('person-modal');
    if (event.target === modal) {
        modal.style.display = 'none';
    }
});

// Search functionality
// SEARCH LOGIC OVERVIEW:
// 1. When searching for a person:
//    - Add the person themselves to matchingIds
//    - Add all their ancestors (parents, grandparents, etc.) to matchingIds
//    - Add their DIRECT children only if generation <= 1 (since gen 2+ are handled dynamically)
//
// 2. Dynamic generation rendering:
//    - If searched person is generation 2+ and has children: render generation 3+
//    - If searched person is generation 3+ with no children: render them under their parent
//    - Only add the specific searched person (not siblings) when rendering their generation
//
// 3. This ensures:
//    - Searching "Noella" shows her parents + her children (not grandchildren)
//    - Searching "Christophe" shows his ancestors + his children (Daniel & Samuel)
//    - Searching "Daniel" shows his ancestors + just him under Great-Grandchildren (not Samuel)

function setupSearch() {
    const searchInput = document.getElementById('search-input');
    
    searchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase().trim();
        
        if (searchTerm === '') {
            // Show all when search is cleared
            document.querySelectorAll('.person-card').forEach(card => {
                card.style.display = 'flex';
            });
            // Remove dynamically added generation 3
            const gen3 = document.getElementById('generation-3');
            if (gen3) {
                gen3.parentElement.remove();
            }
            return;
        }
        
        // Find all matching person IDs
        const matchingIds = new Set();
        const foundPersons = [];
        
        Object.keys(familyData).forEach(id => {
            const person = familyData[id];
            // Use word boundary matching - the search term must match the start of a word or be exact
            const personNameLower = person.name.toLowerCase();
            const regex = new RegExp(`(^|\\s)${searchTerm}`, 'i');
            if (regex.test(personNameLower)) {
                foundPersons.push({ id, person });
                matchingIds.add(id);
                
                // Add all ancestors (parents, grandparents, etc)
                const ancestors = findAncestors(id);
                ancestors.forEach(ancestor => matchingIds.add(ancestor));
                
                // Add DIRECT children only if we're searching for generation 0 or 1
                // For generation 2+, children will be handled by dynamic rendering
                const depth = getGenerationDepth(id);
                if (person.children && depth <= 1) {
                    person.children.forEach(childId => matchingIds.add(childId));
                }
            }
        });
        
        // Remove any existing dynamically rendered generations from previous search
        document.querySelectorAll('[id^="generation-"]').forEach(el => {
            if (!['generation-grandparents', 'generation-1', 'generation-2'].includes(el.id)) {
                el.parentElement.remove();
            }
        });
        
        // Show/hide cards based on matching IDs
        document.querySelectorAll('.person-card').forEach(card => {
            const personId = card.getAttribute('data-person-id');
            if (matchingIds.has(personId)) {
                card.style.display = 'flex';
            } else {
                card.style.display = 'none';
            }
        });
        
        // Collect all generations that need to be dynamically rendered
        const generationsToRender = new Map(); // depth -> { childrenIds, label }
        
        foundPersons.forEach(({ id }) => {
            const person = familyData[id];
            const depth = getGenerationDepth(id);
            
            // If this person has children and is generation 2+, render their children
            if (person && person.children && person.children.length > 0 && depth >= 2) {
                if (!generationsToRender.has(depth + 1)) {
                    generationsToRender.set(depth + 1, { childrenIds: new Set(), label: getGenerationLabel(depth + 1) });
                }
                person.children.forEach(childId => {
                    generationsToRender.get(depth + 1).childrenIds.add(childId);
                    matchingIds.add(childId);
                });
            }
            
            // If this person is generation 3+ with no children, we need to render them under their parent
            if (depth >= 3 && (!person.children || person.children.length === 0)) {
                // Find parent
                let parentId = null;
                Object.keys(familyData).forEach(pid => {
                    const potentialParent = familyData[pid];
                    if (potentialParent && potentialParent.children && potentialParent.children.includes(id)) {
                        parentId = pid;
                    }
                });
                
                if (parentId) {
                    const parentDepth = getGenerationDepth(parentId);
                    if (!generationsToRender.has(parentDepth + 1)) {
                        generationsToRender.set(parentDepth + 1, { childrenIds: new Set(), label: getGenerationLabel(parentDepth + 1) });
                    }
                    // Only add this specific person's ID (not all siblings)
                    generationsToRender.get(parentDepth + 1).childrenIds.add(id);
                }
            }
        });
        
        // Render all needed generations
        generationsToRender.forEach(({ childrenIds, label }, depth) => {
            renderGeneration3(Array.from(childrenIds), null, label, depth);
        });
    });
}

// Get generation label based on depth
function getGenerationLabel(depth) {
    const labels = [
        '',  // 0 - grandparents (no label)
        'Children',  // 1
        'Grandchildren',  // 2
        'Great-Grandchildren',  // 3
        'Great-Great-Grandchildren',  // 4
        'Great-Great-Great-Grandchildren'  // 5
    ];
    // For depths beyond 5, use a pattern
    if (depth > 5) {
        const greats = 'Great-'.repeat(depth - 2);
        return `${greats}Grandchildren`;
    }
    return labels[depth] || '';
}

// Dynamically render generation 3+ (great-grandchildren, etc)
function renderGeneration3(childrenIds, matchingIds = null, generationLabel = 'Great-Grandchildren', generationDepth = 3) {
    const familyTreeContainer = document.querySelector('.family-tree');
    
    const generationContainer = document.createElement('div');
    const label = document.createElement('div');
    label.className = 'generation-label';
    label.textContent = generationLabel;
    generationContainer.appendChild(label);
    
    const generation = document.createElement('div');
    generation.className = 'generation';
    generation.id = `generation-${generationDepth}`;
    
    childrenIds.forEach(childId => {
        const child = getFamilyMember(childId);
        if (child) {
            const card = createPersonCard(child);
            generation.appendChild(card);
        }
    });
    
    generationContainer.appendChild(generation);
    familyTreeContainer.appendChild(generationContainer);
}

// Find ancestors of a person
function findAncestors(personId) {
    const ancestors = [];
    const person = familyData[personId];
    if (!person) return ancestors;
    
    // Find parents
    Object.keys(familyData).forEach(id => {
        const potentialParent = familyData[id];
        if (potentialParent && potentialParent.children && potentialParent.children.includes(personId)) {
            ancestors.push(id);
            // Recursively find their ancestors
            ancestors.push(...findAncestors(id));
        }
    });
    
    return ancestors;
}

// Find all descendants of a person
function findDescendants(personId) {
    const descendants = [];
    const person = familyData[personId];
    if (!person || !person.children) return descendants;
    
    person.children.forEach(childId => {
        descendants.push(childId);
        // Recursively find their descendants
        descendants.push(...findDescendants(childId));
    });
    
    return descendants;
}

// Get generation depth (0 = grandparents, 1 = children, 2 = grandchildren, etc)
function getGenerationDepth(personId) {
    // Check if it's a grandparent
    if (personId === 'grandfather' || personId === 'grandmother') {
        return 0;
    }
    
    // Check if it's a child of grandparents (generation 1)
    const grandfather = familyData.grandfather;
    const grandmother = familyData.grandmother;
    if ((grandfather.children && grandfather.children.includes(personId)) ||
        (grandmother.children && grandmother.children.includes(personId))) {
        return 1;
    }
    
    // Count how many generations from the top by finding direct parent
    return countGenerationsFromTop(personId);
}

// Count how many generations away from grandparents
function countGenerationsFromTop(personId) {
    // Find the direct parent only (not all ancestors)
    let parentId = null;
    Object.keys(familyData).forEach(id => {
        const potentialParent = familyData[id];
        if (potentialParent && potentialParent.children && potentialParent.children.includes(personId)) {
            parentId = id;
        }
    });
    
    // If no parent found, return 3 (unknown depth)
    if (!parentId) {
        return 3;
    }
    
    // Recursively find parent's generation and add 1
    return getGenerationDepth(parentId) + 1;
}

// Initialize the family tree when page loads
document.addEventListener('DOMContentLoaded', () => {
    renderFamilyTree();
    setupSearch();
});

